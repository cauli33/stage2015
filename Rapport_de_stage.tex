\documentclass[a4paper]{article}


\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{eufrak}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}
\usepackage{bm}
\usepackage{sagetex}
\usepackage{array,multirow,makecell}
\usepackage{amssymb}
\usepackage[margin=3cm]{geometry}
\usepackage{colortbl}
\usepackage{hyperref}

\definecolor{string-col}{rgb}{0.8,0.1,0.1}
\definecolor{keyword-col}{rgb}{0.2,0.2,0.6}
\definecolor{comment-col}{rgb}{0.6,0.3,0.1}

\newtheorem{Def}{Définition}[section]
\newtheorem{Prop}[Def]{Proposition}
\newtheorem{Propr}[Def]{Propriété}
\newtheorem{Th}[Def]{Théorème}
\usepackage{fancyhdr}
\pagestyle{fancy}
\begin{document}
\lstset{
upquote=true,
language=Python,
keywordstyle=\color{keyword-col}\bfseries,
stringstyle=\color{string-col}\ttfamily,
commentstyle=\color{comment-col}\ttfamily,
showstringspaces=false,
literate={~} {$\sim$}{1},
numbers=left
}
\thispagestyle{empty}
\hspace{-2cm}
\begin{tikzpicture}
  \node at (0, 21) {\Huge Rapport de stage};
  \node at (0, 20) {\Large Les designs combinatoires et le logiciel Sage} ;
\coordinate (P7) at (-7,0);
\coordinate (P5) at (7,0);
\coordinate (P1) at (0,18);
\coordinate (P6) at (barycentric cs:P5=1,P7=1);
\coordinate (P3) at (barycentric cs:P1=1.2,P7=1);
\coordinate (P2) at (barycentric cs:P1=1.2,P5=1);
\coordinate (P4) at (barycentric cs:P6=2,P1=1);

\node[anchor=west] at (-8,17) {\Large Quentin Honoré};
\node[anchor=east] at (9,16.5) {\large Maitre de stage : Vincent Delecroix};
\node[anchor=east] at (9,16) {\large Tuteur enseignant : Cédric Jai};
\node[anchor=east] at (9,20.5) {\includegraphics[scale=0.12]{inp.png}};
\node[anchor=west] at (-9,20.5) {\includegraphics[scale=0.35]{CPP.png}};
\node[anchor=west] at (-8,16) {\Large Du 4 Mai au 26 Juin};
\draw[thick] (P1) -- (P7) -- (P5) -- cycle;
\draw[thick] (P3) -- (P5);
\draw[thick] (P1) -- (P6);
\draw[thick] (P2) -- (P7);

\draw[thick] (P3) .. controls (-3,2) .. (P6) .. controls (3,2) .. (P2) .. controls (0,12) .. (P3);
\foreach \x in {1,2,3,4,5,6,7}
  \node at (P\x) {\includegraphics[scale=0.3]{dobble\x.png}};
\end{tikzpicture}
\newpage
\thispagestyle{empty}
\strut
\newpage
\tableofcontents
\newpage
\section*{Remerciements}
\addcontentsline{toc}{section}{Remerciements}
En premier lieu, je tiens à remercier mon maître de stage, Mr Vincent DELECROIX pour m'avoir accueilli chaleureusement, accompagné et aidé au cours de ces 8 semaines de stage. Je lui suis reconnaissant pour le temps qu'il m'a consacré.\\
Je remercie mon tuteur, Mr Jai pour le suivi tout au long de mon stage.\\
Je remercie Mme Hinnenberger et Mme Roubineau de m'avoir accueilli pour répondre à mes questions sur l'organisation du LaBRI.\\
Enfin, je remercie l'équipe entière du LaBRI de m'avoir proposé ce stage et de m'avoir accueilli pendant ces 8 semaines dans leur établissement.
\newpage
\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
Ce rapport est consacré au stage que j'ai effectué dans le cadre de ma formation à la Prépa des INP. Je devais effectuer un stage d'une durée minimale de 6 semaines afin de découvrir les métiers correspondant à ma formation.
J'ai donc fait mon stage au LaBRI, Laboratoire de Recherche Informatique à Bordeaux, du 4 Mai au 26 Juin où l'on m'a proposé un stage avec pour sujet ``\textit{Les designs combinatoires et le logiciel Sage}''.\\
Ce stage m'a permis de mettre en pratique les connaissances acquises pendant les cours d'Informatique à la Prépa des INP, le logiciel Sage étant basé sur le langage de programmation Python. Il m'a permis d'acquérir de nouvelles compétences sur la programmation en Python et sur les méthodes de développement d'un logiciel open source avec par exemple le logiciel git et sur la rédaction des textes (y compris ce rapport) avec \LaTeX. J'ai aussi commencé à lire la littérature anglophone, bien plus vaste que la littérature disponible en français, tant sur les plans projectifs que pour le développement de Sage et les outils de programmation. \\
Au cours de ce stage j'ai pu découvrir les métiers de la recherche et le fonctionnement d'un laboratoire de recherche en Informatique. Il m'a conforté dans mon choix de l'Enseirb-Matmeca en filière Informatique comme école d'ingénieur et m'a fait réfléchir à une possible continuation sur un doctorat pour ensuite travailler dans la recherche.\\
L'objectif de ce stage était d'abord de se familiariser avec les designs combinatoires. Ensuite, il m'a fallu découvrir le fonctionnement du logiciel Sage et comment se fait son développement afin d'y implémenter certaines des constructions étudiées.\bigskip \\
Dans ce rapport, je présenterais dans une première partie le LaBRI et ce qu'il s'y passe, puis j'aborderais tous les concepts mathématiques sur lesquels j'ai travaillé nécessaires à la compréhension de mes travaux, et enfin je présenterais Sage et les travaux que j'ai fait sur ce logiciel. 
\newpage
\section{Présentation du LaBRI}
\begin{minipage}{0.4\linewidth}
\includegraphics[scale=0.5]{labri.jpeg}
\end{minipage}\hfill
\begin{minipage}{0.55\linewidth}
Le LaBRI est une unité mixte de recherche associée à Bordeaux INP, à l'université de Bordeaux et au CNRS et depuis 2002 partenaire de l'Inria (Institut national de recherche en informatique et en automatique) avec lequel sont mises en commun certaines équipes de recherche. Il y a aujourd'hui au LaBRI environ 320 personnes dont 113 enseignant-e-s chercheu-r-ses, 37 chercheu-r-ses, 22 personnels administratifs et plus de 140 contractuels (doctorant-e-s, ingénieur-e-s).\vspace{2\baselineskip}
\end{minipage}
Le LaBRI est une unité mixte de recherche associée à Bordeaux INP, à l'université de Bordeaux et au CNRS et depuis 2002 partenaire de l'Inria (Institut national de recherche en informatique et en automatique) avec lequel sont mises en commun certaines équipes de rechercher. Il y a aujourd'hui au LaBRI environ 320 personnes dont 113 enseignant-e-s chercheu-r-ses, 37 chercheu-r-ses, 22 personnels administratifs et plus de 140 contractuels (doctorant-e-s, ingénieur-e-s).\vspace{2\baselineskip}\\
Le LaBRI est en contrat quinquennal : un rapport est fait tous les 5 ans sur les recherches effectuées dont dépendront le renouvellement du contrat pour les 5 années à suivre. Ce contrat est fait par le HCERS (Haut Conseil de l'Evaluation de la Recherche et de l'enseignement Supérieur).
Les financements du LaBRI sont accordés par Bordeaux INP, l'université de Bordeaux et le CNRS. Les personnes travaillant au LaBRI sont engagées par l'une de ces trois institutions et ont été affectées à ce laboratoire. Les chercheu-r-ses sont sous contrat avec le CNRS et les personnes engagées par l'université et Bordeaux INP sont plutôt des enseignant-e-s chercheu-r-ses.\medskip\\
Il y a au LaBRI autant de recherche théorique que de recherche appliquée. Certaines personnes en recherche appliquée ont des financements pour leur projet par des entreprises comme Thales avec un projet sur les drones ou Sogeti sur l'adaptation et la diffusion des flux vidéo. Pour la recherche théorique, les financements sont plutôt nécessaires pour rencontrer les autres personnes travaillant sur le même sujet ailleurs en France ou dans le monde. Pour cela, des appels PEPS (Projets Exploratoires Premier Soutien) sont faits par le CNRS et des aides sont accordées par l'Agence Nationale de la Recherche.\bigskip\\
Six grandes équipes composent le laboratoire:
\begin{itemize}
\item Combinatoire et Algorithmique
  \begin{itemize}
  \item Combinatoire énumérative et algébrique
  \item Graphes et applications
  \item Algorithmique distribuée
    \end{itemize}
\item Image et Son
\item Méthodes Formelles
\item Modèles et Algorithmes pour la Bioinformatique et la Visualisation d'informations
\item Programmation, Réseaux et Systèmes
\item Supports et Algorithmes pour les applications numériques hautes performances
\end{itemize}
\bigskip
J'ai travaillé pendant ce stage dans l'équipe \textit{Combinatoire énumérative et Algébrique} du thème Combinatoire et Algorithmique.\vspace{2\baselineskip}\\
\newpage
Le LaBRI collabore avec l'Inria mais certaines équipes ont aussi des projets avec d'autres instituts ou laboratoires de recherche. L'équipe ``Modèles et Algorithmes pour la Bioinformatique et la Visualisation d'informations'' travaille avec l'université Bordeaux Segalen. L'équipe ``Image et Son'' a fait des travaux avec l'université Bordeaux Montaigne ainsi que le laboratoire PACEA (laboratoire d'archéologie) sur les sciences du langage et en archéologie comme par exemple un projet d'impression 3D d'ossements.\bigskip\\

Le travail est rythmé par un grand nombre d'exposés et de conférences. Les sujets étant aussi différents que les équipes présentes au LaBRI j'ai assisté à trois conférences au cours de mon stage sur des sujets que j'étais susceptible de comprendre ou en rapport avec le sujet du stage. J'ai donc assisté à une leçon de Bruno Salvy, enseignant-chercheur à l'ENS Lyon et à l'Inria sur ``\textit{Les récurrences et équations différentielles linéaires vues comme structures de données}'' à l'IMB (Institut de Mathématiques de Bordeaux). J'ai aussi suivi un exposé sur comment \textit{Calculer les distances dans un graphe en temps constant avec des étiquettes de 0.793n bits} par Cyril Gavoille, chercheur au LaBRI. Enfin, j'ai assisté à une conférence par Alain Franc, chercheur à l'Inra (Institut National de Recherche Agronomique) sur l'élaboration de modèles mathématiques pour schématiser la biodiversité sur l'exemple de la forêt guyanaise.

\newpage
\section{Les plans projectifs finis}
\subsection{Définitions}
\begin{Def}
Soit P un ensemble fini (dont les éléments sont appelés \emph{points}) et D un sous ensemble des parties de P (dont les éléments sont appelés \emph{droites}). \\
On dit que le couple (P,D) est un \emph{plan projectif fini} si et seulement si: \\
$\cdot$ Par deux points distincts passe une unique droite. \\
$\cdot$ Deux droites distinctes se coupent en un unique point. \\
$\cdot$ Il existe un quadrilatère (4 points tels que pour chaque triplet, les 3 points ne sont pas alignés).
\end{Def}
\textbf{Remarque}\\
  $\cdot$ Les 2 premières propriétés sont symétriques : on peut facilement numéroter les droites et assigner aux points la liste des numéros des droites passant par ceux-ci. Les anciens points sont alors les nouvelles droites et inversement. On voit alors que dans ce cas si par deux points distincts passaient une unique droite, avec la nouvelle version, on a que deux droites distinctes se coupent en un unique point. \\
$\cdot$ Un plan projectif est un cas particulier des structures d'incidence (un ensemble de points et un ensemble de droites) qui sont des designs combinatoires.\bigskip\\
On va essayer de construire le plus petit plan projectif fini. On construit donc d'abord un quadrilatère. Par chaque paire de points doit passer une droite.
\begin{center}
\includegraphics[scale=0.5]{planproj1.pdf}
\end{center}
On voit alors que les deux droites horizontales ne se coupent pas. De même, pour les deux droites verticales et les deux diagonales. Il nous faut alors construire une intersection pour chacune de ces paires de droite. On définit alors les intersections dites ``à l'infini'', c'est l'idée de base de la géométrie projective. De la même manière que pour le point de fuite chez les peintres, on dit que deux droites parallèles se coupent à l'infini. Imaginez vous sur une route sans virage, les deux bordures sont bien parallèles mais en regardant au loin, nous avons l'impression que la route se rétrécit pour ne devenir qu'un point.\\
\begin{center}
\includegraphics[scale=0.5]{planproj2.pdf}
\end{center}
\newpage
En ajoutant une droite ``à l'infini'' (comme un horizon), on obtient notre plan projectif.
\begin{center}
\includegraphics[scale=0.5]{test_tikz.pdf}
\end{center}
\vspace{2\baselineskip}
\begin{Prop}
  Soit (P,D) un plan projectif fini. Alors il existe un entier $k$ ($k \geq 2$) tel que:
  \begin{itemize}
  \item Chaque droite contient $k+1$ points.
  \item Par chaque point passent $k+1$ droites.
  \item $card(D) = card(P)=k^2+k+1$
    \end{itemize}
Ce nombre $k$ est appelé \emph{ordre} du plan.
\end{Prop}
\textbf{Preuve}\\
On va d'abord montrer que toutes les droites ont le même nombre de points. Prenons deux droites $D_1$ et $D_2$, ces deux droites se coupent en un point. Etant donné qu'il existe un quadrilatère, il existe un point p tel que $p \notin D_1$ et $p \notin D_2$. Pour chacun des points x de $D_1$ différents du point d'intersection, il existe une droite passant par x et p. Cette droite coupe $D_2$ en un seul point y. On vient de créer la bijection $x \longrightarrow y$ des points de $D_1$ dans les points de $D_2$ : x n'a qu'une seule image et on trouve quelque soit y un seul antécédent en refaisant la construction inverse (en commencant par la droite passant par y et p). Elles ont donc le même nombre de points que l'on note $k+1$.\smallskip\\
\begin{center}
  \includegraphics[scale=1]{preuve.pdf}
  \end{center}
On montre maintenant qu'il y a autant de points dans une droite que de droites passant par un point. On prend un point p et une droite D ne contenant pas p. Pour chacun des $k+1$ points de $D$, on fait passer une droite entre p et ce point. On a donc $k+1$ droites passant par ce point. Supposons qu'il y ait une autre droite D' passant par p. Alors, on peut trouver l'intersection entre D et D' qui par définition est à la fois un point de D et de D'. Comme cette intersection est un point de D, il existe déja une droite passant par par celle-ci et par p. Or, on sait que par deux points passent une unique droite, donc $D'=D$.\\
Montrons maintenant que le nombre de points est $k^2+k+1$. Si on considère un point p, $k+1$ droites passent par ce point. Sur chacune de ces droites, il y a $k+1$ points, donc $k$ si on ne compte pas le point p. On a donc $k(k+1)$ points en plus du point p, soit:
\begin{center}
$card(P)=k(k+1)+1=k^2+k+1$
\end{center}
\bigskip
\textbf{Remarque}\\
$\cdot$On ne peut pas avoir de plan projectif de cardinal 6,8,9,10,11,12,14...: \\
$2^2+2+1=7$ \\
  $3^2+3+1=13$\\

\begin{Def}{Arc} \\
  Un arc dans un plan projectif est un ensemble de points tel que tout triplet dans cet ensemble n'est pas aligné.
\end{Def}
\begin{Def}{Ensemble bloquant}\\
 $\cdot$ Un ensemble bloquant (\emph{blocking set} en anglais) est un ensemble de points dans un plan projectif que chaque ligne coupe mais qui ne contient pas une ligne entière.\\
  $\cdot$ Un ensemble bloquant de plus petite cardinalité est appelé \emph{committee} en anglais.\\
\end{Def}
\bigskip
\begin{Propr}{Propriété de Desargues}\\
Cette propriété est toujours vérifiée dans le plan euclidien, on se place ici dans un plan projectif.
  Soit deux triangles (non plats) ABC et A'B'C' de sommets deux à deux distincts (A de A', B de B' et C de C'). \\
  Les 3 droites (AA'), (BB') et (CC') sont concourantes (en un point S) \textbf{si et seulement si} les 3 points $P = (BC) \cap (B'C')$, $Q = (AC) \cap (A'C')$ et $R = (AB) \cap (A'B')$ sont alignés (sur une droite d)
  \end{Propr}
\begin{center}
\includegraphics[scale=0.6]{desargues.png}  
\end{center}  
\newpage
\subsection{Le jeu du Dobble}
Le jeu du Dobble est un exemple de plan projectif fini. Si vous ne le connaissez pas, le Dobble est un jeu composé de 55 cartes sur chacune desquelles sont dessinés 8 symboles\vspace{1\baselineskip} différents.\\
  \begin{minipage}{0.55\linewidth}
A chaque tour, il faut reconnaître le plus rapidement quel est le symbole commun entre sa propre carte et celle au milieu. Le jeu ne serait alors pas juste si l'un-e des joueu-r-ses avait deux symboles en commun avec la carte du milieu tandis que l'autre n'en a aucun.
  Ces cartes sont donc construites de telle manière que pour toute paire de carte, il y ait un et un seul symbole en commun. On peut voir le Dobble comme un plan projectif en prenant pour droites les cartes et pour points les symboles mais aussi inversement en prenant pour points les cartes et pour droites les symboles.\vspace{1\baselineskip}\\
\end{minipage}\hfill
\begin{minipage}{0.55\linewidth}
\begin{center}
\includegraphics[scale=0.3]{dobble-2.jpg}
\end{center}
\end{minipage}

Avec 8 symboles par carte, on a donc un plan projectif d'ordre 7. Or $7^2+7+1=57$, il manque donc 2 cartes au Dobble! Si on étudie les cartes, on voit bien que le bonhomme de neige n'apparait que sur 6 cartes et quelques autres symboles sur 7 cartes. On arrive au même jeu si l'on construit nous même un plan projectif d'ordre 7 et qu'on retire 2 droites passant par un même point à la fin.
En ajoutant ces deux cartes manquantes, le jeu du Dobble vérifie toutes les propriétés des plans projectifs. Néanmoins, même avec 2 cartes en moins, le Dobble garde sa propriété la plus importante: il y a toujours un unique symbole pour deux cartes même en enlevant 2 cartes. Ceci est d'ailleurs vrai pour tout sous-ensemble du jeu du Dobble. Que l'on prenne deux cartes d'un sous-ensemble ou deux cartes du jeu complet, tant que le jeu de base a été construit avec cette propriété, on aura toujours un symbole en commun.\vspace{1\baselineskip}\\
J'ai pu me procurer un jeu du Dobble. En numérotant les symboles (bonhomme orange $\rightarrow$ 0, bombe $\rightarrow$ 1, ..., igloo $\rightarrow$ 56), j'ai pu créer la liste des droites en ajoutant les 2 cartes manquantes et les manipuler avec le logiciel Sage.
\begin{sageverbatim}
 sage: blocks = [[6,11,21,27,43,50,53,55],[4,10,20,26,35,39,48,53],
        [8,10,28,31,34,45,54,55]], ... ,[0,46,48,34,32,27,52,14]]
\end{sageverbatim}
Après avoir importé la classe \texttt{BalancedIncompleteBlockDesign}, on peut créer le plan projectif du Dobble:
\begin{sageverbatim}
 sage: from sage.combinat.designs.bibd import BalancedIncompleteBlockDesign
 sage: B = BalancedIncompleteBlockDesign(57,blocks)
 sage: B
 (57,8,1)-Balanced Incomplete Block Design
\end{sageverbatim}
Les \textit{Balanced Incomplete Block Design} sont des designs combinatoires ou plus précisemment des structures d'incidence avec 3 paramètres, ici $(57, 8, 1)$, ce qui signifie qu'il y a dans cette structure 57 points, 8 points par droite et par deux points passent une droite, ce qui correspond parfaitement à ce que l'on a vu sur les plans projectifs (ici $k=7$ : $k+1=8$ et $k^2+k+1=57$).
Le Dobble est un plan projectif d'ordre 7.
\newpage
Je me suis alors servi d'un programme que j'avais fait précédemment pour les plans de Hughes. La fonction \texttt{is\_desarguesian\_plane} itère sur les paires de triangles (non-plats) simplement pour vérifier que la propriété de Desargues est vérifiée. En pratique, si un plan n'est pas desarguesien, le programme affiche rapidement des centaines de paires de triangle pour lesquelles le théorème n'est pas vérifié et il n'est pas nécessaire de laisser tourner le programme plus longtemps:
\begin{sageverbatim}
 sage: is_desarguesian_plane(B)
  
\end{sageverbatim}
J'ai laissé tourner le programme longtemps mais celui-ci est beaucoup trop long. Il est généralement simple de vérifier qu'un plan n'est pas desarguesien mais il serait intéressant de trouver une méthode efficace pour savoir si un plan est desarguesien.\\ 
On peut considérer que le Dobble (en ajoutant les cartes manquantes) est un plan projectif fini d'ordre 7 desarguesien (comme dit précédemment, si il ne l'était pas, le programme aurait rapidement affiché beaucoup de combinaisons qui ne vérifient pas la propriété de Desargues).
\bigskip\\
Le Dobble nous permet aussi de mieux comprendre les notions d'arc et de blocking set. Ici, les points sont les cartes et les droites sont les points:\\
$\cdot$ Un arc est un tas de cartes tel qu'il n'y ait pas plus de deux cartes contenant le même symbole, on a un arc. \\
$\cdot$ Un ensemble bloquant est un des deux tas lorsque l'on sépare le jeu du Dobble de telle manière que tous les symboles soient représentés dans chacun des deux tas. En effet, pour chaque droite, on trouve au moins un point de chaque droite dans chacun des tas et puisqu'on en trouve au moins un dans l'autre tas aussi, aucun des 2 tas ne contient tous les points de la droite.
\newpage
\subsection{Les corps finis}
Les plans projectifs que j'ai étudiés sont tous construits en utilisant les corps finis.
\begin{Def}
  Un corps fini est un corps commutatif qui est en plus fini.\\
  \begin{itemize}
\item il y a un élément neutre pour l'addition (noté $0$),
\item il y a un élément neutre pour la multiplication (noté $1$),
\item tous les éléments admettent un inverse pour l'addition,
\item tous les éléments différents de 0 ont un inverse pour la multiplication,
\item et certaines propriétés de commutativité, associativité et distributivité.
  \end{itemize}
  \end{Def}
Un corps fini est uniquement défini par son cardinal qui doit être la puissance d'un nombre premier. On le note $\mathbb{F}_n$ ou GF(n).
Si n est un nombre premier, alors $\mathbb{F}_n$ est $\mathbb{Z}/n\mathbb{Z}$.\\
  On utilise la multiplication et l'addition usuelles congrues à $n$. Par exemple si on se place dans $\mathbb{F}_3$:\\
  $2*2=4$ et $4 \equiv 1 [3]$ donc dans $\mathbb{F}_3$, $2*2=1$
  De la même façon, $1+2=0$ sur $\mathbb{F}_3$\vspace{1\baselineskip}.\\
Il faut bien garder en tête que les éléments de ces corps finis n'ont que la notation en commun avec les entiers naturels que nous connaissons. L'élément que nous notons 2 dans $\mathbb{F}_3$ n'est pas l'entier 2.\vspace{1\baselineskip}\\
\textbf{Exemple}\\
  Par exemple, l'ensemble des réels est un corps tandis que l'ensemble des entiers naturels n'en est pas un : 2 n'admet pas d'inverse multiplicatif ni d'inverse additif.
\begin{center}
$\mathbb{F}_2 $\\
\begin{tabular}{|c|c|c|}
  \hline
  + & \textbf{0} & \textbf{1} \\
  \hline
  \textbf{0} & 0 & 1 \\
  \hline
  \textbf{1} & 1 & 0 \\
  \hline
\end{tabular}
\begin{tabular}{|c|c|c|}
  \hline
  $*$ & \textbf{0} & \textbf{1} \\
  \hline
  \textbf{0} & 0 & 0\\
  \hline
  \textbf{1} & 0 & 1\\
  \hline
\end{tabular}\\
\vspace{1\baselineskip}
$\mathbb{F}_3 $\\
\begin{tabular}{|c|c|c|c|}
  \hline
  + & \textbf{0} & \textbf{1} & \textbf{2} \\
  \hline
  \textbf{0} & 0 & 1 & 2 \\
  \hline
  \textbf{1} & 1 & 2 & 0 \\
  \hline
  \textbf{2} & 2 & 0 & 1 \\
  \hline
\end{tabular}
\begin{tabular}{|c|c|c|c|}
  \hline
  $*$ & \textbf{0} & \textbf{1} & \textbf{2} \\
  \hline
  \textbf{0} & 0 & 0 & 0 \\
  \hline
  \textbf{1} & 0 & 1 & 2 \\
  \hline
  \textbf{2} & 0 & 2 & 1 \\
  \hline
\end{tabular}\\
\vspace{1\baselineskip}
$\mathbb{F}_4$\\
\begin{tabular}{|c|c|c|c|c|}
  \hline
  + & \textbf{0} & \textbf{1} & $\bm{x}$ & $\bm{x+1}$ \\
  \hline
  \textbf{0} & 0 & 1 & $x$ & $x+1$ \\
  \hline
  \textbf{1} & 1 & 0 & $x+1$ & $x$ \\
  \hline
  $\bm{x}$ & $x$ & $x+1$ & 0 & 1 \\
  \hline
  $\bm{x+1}$ & $x+1$ & $x$ & 1 & 0 \\
  \hline
\end{tabular}
\begin{tabular}{|c|c|c|c|c|}
  \hline
  $*$ & \textbf{0} & \textbf{1} & $\bm{x}$ & $\bm{x+1}$ \\
  \hline
  \textbf{0} & 0 & 0 & 0 & 0 \\
  \hline
  \textbf{1} & 0 & 1 & $x$ & $x+1$ \\
  \hline
  $\bm{x}$ & 0 & $x$ & $x+1$ & 1 \\
  \hline
  $\bm{x+1}$ & 0 & $x+1$ & 1 & $x$\\
  \hline
\end{tabular}
\end{center}
\bigskip
Sage nous permet de manipuler ces corps finis :
\begin{sageverbatim}
 sage: K = FiniteField(3)
 sage: K(1)+K(2)
 0
 sage: K(2)*K(2)
 1
 sage: H = FiniteField(4, 'x')
 sage: x = H.gen()
 sage: x + x
 0
 sage: type(x+x)
 <type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>
\end{sageverbatim}
\newpage

\subsection{Plan desarguesien}
On peut construire les plans desarguesiens à partir des corps finis. Comme leur nom l'indique, la propriété de Desargues est vérifiée dans ces plans.
Pour construire un plan à partir du corps $GF(q)$,
nous allons donner aux points des coordonnées $(x,y,z)$ avec $x,y,z \in GF(q)$ et $(x,y,z) \neq (0,0,0)$. Les points sont définis à multiplication près : pour $k \neq 0$, $k(x,y,z) \equiv (kx,ky,kz) \equiv (x,y,z)$. On notera donc $(x:y:z)$ la famille des points équivalents à $(x,y,z)$.\\
Ici aussi, comme pour les plans euclidiens, les droites ont une équation de la forme $ax + by + cz = 0$ avec $(a,b,c) \neq (0,0,0)$. Les droites correspondantes seront notées $(a:b:c)$.\\
On va reprendre les points du premier exemple, numéroter les points dans le plan avec $z=0$ si c'est un point à l'infini et $z=1$ sinon. En traçant les droites à partir de GF(2), on voit qu'on obtient bien le même plan projectif que celui construit précédemment. 
\begin{center}
  \includegraphics[scale=0.5]{droitestikz.pdf}
  \end{center}
\vspace{2\baselineskip}
\subsection{Plan de Hughes}
Sur certains plans projectifs, la propriété de Desargues n'est pas vérifiée, c'est le cas des plans de Hughes que nous allons construire dans cette section.\medskip\\

Soit q un nombre premier impair (i.e. différent de 2).
Le plan de Hughes se base sur le corps fini $\mathbb{F}_{q^2}$ en utilisant toutefois une multiplication définie différemment de la multiplication ordinaire:\\


$x \circ y =
        \begin{cases}
        x\ y & \text{si y est un carré dans GF($q^2$)}\\
        x^q\ y & \text{sinon}
        \end{cases}
        $
        \smallskip\\
On voit facilement que cette multiplication n'est pas commutative dans $\mathbb{F}_4$ par exemple:\\
$1 \circ 2 = 1*2 = 2$\\
$2 \circ 1 = 2^2*1 = 1*1 =1$
        
        On construit $q^2-q+1$ droites d'équation $x + \alpha \circ y + z = 0$ que l'on notera $L(\alpha)$ comme on l'a fait pour la construction des plans projectifs sur des corps finis. Soit A une matrice de taille $3\times3$ dont les éléments appartiennent à $\mathbb{F}_q$ et telle que $A^{q^2+q+1}=kI$ mais pas pour une puissance plus petite. Pour chacune des droites $L(\alpha)$, on définit l'ensemble de droites suivant:
\begin{center}
 $ \{A^nL(\alpha) | 0 \leq n \leq q^2 + q\}$
\end{center}
\smallskip
J'ai fait puis ajouté la fonction \texttt{HughesPlane} dans le fichier \texttt{block\_design.py}, fichier Python dans le répertoire \texttt{sage/combinat/designs/} qui regroupe certaines fonctions comme \texttt{projective\_plane}. Cette dernière fonction utilise la construction à partir des corps finis faite par la fonction \\ \texttt{DesarguesianProjectivePlaneDesign} elle aussi dans ce fichier.\\
\newpage
Cette fonction s'appuie sur deux autres fonctions dont une fabrique une matrice A comme expliqué ci-dessus et une autre qui normalise les points ( $(a,b,c)k \equiv (a,b,c)$ ). La fonction principale \texttt{HughesPlane} suit la méthode de construction expliquée précédemment.
\begin{sageverbatim}
 sage: H = designs.HughesPlane(9)
 sage: H
 (91,10,1)-Balanced Incomplete Block Design
\end{sageverbatim}
Nous allons montrer que ce plan de Hughes n'est pas desarguesien. J'ai recherché avec un algorithme les points qui nous permettraient de montrer ceci, je prends donc ici les triangles $(0,1,10)$ et $(57, 70, 59)$. Nous allons montrer que les intersection $D_{0,1} \cap D_{57,70}$, $D_{1,10} \cap D_{70,59}$ et $D_{10,0} \cap D_{59,57}$ sont alignées tandis que les droites $D_{0,70}$, $D_{1,59}$ et $D_{10,57}$ ne se rejoignent pas en un seul point.La méthode $.blocks()$ depuis une structure d'incidence permet de nous donner la liste des droites. Il y en a 91 donc je me contente d'en afficher 4.
\begin{sageverbatim}
 sage: blocks = H.blocks()
 sage: blocks[:3]
 [[0, 1, 2, 3, 4, 5, 6, 7, 8, 81],
 [0, 9, 18, 27, 36, 45, 54, 63, 72, 90],
 [0, 10, 20, 30, 40, 50, 60, 70, 80, 89],
 [0, 11, 23, 31, 43, 51, 55, 71, 75, 88]]
\end{sageverbatim}
On crée une fonction \texttt{line} qui à p,q associe la droite qui passe par p et q. On crée en fait un générateur auquel on applique la fonction \texttt{next()} pour donner le premier élément (il n'y a de toute façon qu'une seule droite passant par deux points dans un plan projectif).
\begin{sageverbatim}
 line = lambda p,q: next((b for b in blocks if p in b and q in b))
\end{sageverbatim}
$line$ nous renvoie une liste (une droite est une liste de points). Nous cherchons à avoir l'intersection de deux listes, ce qui n'est pas possible. Grâce à la fonction $set$, on transforme une des deux listes en un ensemble que l'on peut maintenant utiliser pour trouver l'intersection avec une liste. Nos intersections sont donc les points 2, 73 et 60.
\begin{sageverbatim}
 sage: set(line(0, 1)).intersection(line(57, 70))
 {2}
 sage: set(line(1, 10)).intersection(line(70, 59))
 {73}
 sage: set(line(10, 0)).intersection(line(59, 57))
 {60}
\end{sageverbatim}
La droite passant par 2 et 73 est la-même que celle passant par 73 et 60, on a donc bien que les points 2, 60 et 73 sont alignés.
\begin{sageverbatim}
 sage: line(2, 73) == line(73, 60)
 True
\end{sageverbatim}
Les droites $D_{0,70}$, $D_{1,59}$ et $D_{10,57}$ ne sont pas concourrantes.
\begin{sageverbatim}
 sage: set(line(0, 57)).intersection(line(1, 70))
 {82}
 sage: set(line(1, 70)).intersection(line(10, 59))
 {72}
\end{sageverbatim}
\newpage
Plus concrètement voilà ce qu'il se passe dans ce plan de Hughes:
\begin{center}
  \includegraphics[scale=1.5]{Hughestikz.pdf}
\end{center}
72 et 82 devraient être le même point si le théorème de Desargues s'appliquait ici.

\newpage
\section{Le logiciel Sage}
\subsection{Présentation}
\begin{minipage}{0.6\linewidth}
  \textit{SageMath} est un logiciel libre de mathématiques qui se veut être une alternative libre à Matlab, Maple...\medskip\\
  Il est basé sur le langage Python et combine plusieurs dizaines de programmes libres dans une interface commune. Sage permet de travailler sur une vaste gamme de Mathématiques. Au cours de ce stage je ne travaille que dans la partie combinatoire de Sage et plus précisemment dans les designs combinatoires.
\end{minipage}\hfill
\begin{minipage}{0.3\linewidth}
\includegraphics[scale=0.4]{logo.png}  
\end{minipage}
\bigskip\\
Les tableaux qui suivent sont non-exhaustifs, ils permettent de situer dans quelle branche de Sage j'ai travaillé.\smallskip\\
\begin{tabular}{|c|c|c|c|c|c|c|c|}
  \hline
  algebras & calculus & \cellcolor{lightgray}\color{white}{combinat} & crypto & databases & dynamics & finances & functions\\
  \hline
  geometry & graphs & groups & interacts & interfaces & logic & matrix & numerical\\
  \hline
  probability & quadratic\_forms & rings & sat & sets & stats & structure & symbolic\\
  \hline
\end{tabular}
\smallskip\\
Dans \texttt{combinat}, on a:\smallskip \\
\begin{tabular}{|c|c|c|c|}
  \hline
  affine\_permutation.py & algebraic\_combinatorics.py & binary\_tree.py & cartesian\_product.py \\
  \hline
  crystals & \cellcolor{lightgray}\color{white}{designs} & enumerated\_sets.py & family\\
  \hline
  matrices & partition.py & species & subset.py\\
  \hline
  \end{tabular}
\vspace{1\baselineskip}\\
Sage étant un logiciel libre, le code source est entièrement accessible et modifiable. Il est en constante évolution, plusieurs mises à jours stables sortent par année. Le développement de Sage (les implémentations de nouvelles fonctions, de nouvelles classes, les corrections de bugs) se fait par tou-te-s les utilisat-rice-teurs qui proposent via le Trac de Sage (application web Open Source de gestion de projets) leur apport qui est ensuite discuté et éventuellement validé.

\subsection*{Mon travail sur Sage}
Tous les fichiers dont je parle ici sont dans le répertoire \texttt{sage/src/sage/combinat/designs/}. \medskip\\
\begin{itemize}
\item Ticket \#18439 : \url{http://trac.sagemath.org/ticket/18439}\\
  \textit{Ajout de la fonction \texttt{is\_projective\_plane} dans \texttt{incidence\_structure.py}}\\
 La fonction a été modifiée puis placée dans \texttt{design\_pyx.pyx} après discussion sur le trac. J'ai en plus corrigé une mauvaise référence faite dans le code d'une autre fonction. Cette erreur a été repérée pendant la discussion sur le trac. Fonction dans Sage depuis le 4 Juin avec la beta3 de Sage6.8.\smallskip\\
\item Ticket \#18527 : \url{http://trac.sagemath.org/ticket/18527}\\
 \textit{Ajout de la fonction \texttt{HughesPlane} dans \texttt{block\_design.py}}\\
  La fonction a été acceptée après quelques modifications, elle est dans Sage depuis le 4 Juin avec la beta3 de Sage6.8.\smallskip\\
\item Ticket \#18608 : \url{http://trac.sagemath.org/ticket/18608}\\
\textit{Ajout des méthodes \texttt{arc} et \texttt{blocking\_set} pour la classe \texttt{BalancedIncompleteBlockDesign} dans \texttt{bibd.py}}\\
  Encore en discussion sur le trac à la remise du rapport de stage.\\
\end{itemize}  
\newpage
\subsection{Ajout d'une fonction dans Sage}
Dans cette section, je vais détailler les étapes nécessaires pour intégrer une fonction en Sage et ensuite la proposer sur le trac. Je prendrais l'exemple de la fonction \texttt{HughesPlane} (dont le code est visible dans l'annexe 1 et la documentation entière dans l'annexe 2).\bigskip\\ 
Après avoir codé une nouvelle fonction en langage Python, il est nécessaire de la tester avec le logiciel sage:
\begin{center}
\includegraphics[scale=0.7]{hughessage.png}\vspace{1\baselineskip}\\
Test de la fonction dans Sage
\end{center}
\medskip
Si il n'y a pas de soucis de fonctionnement, on peut alors copier notre fonction dans le code de Sage. Nous allons ici le mettre dans le fichier \texttt{block\_design.py} dans le dossier \texttt{sage/src/sage/combinat/designs/}.\medskip\\
Toute fonction de Sage doit être accompagnée d'une documentation avec un format bien défini.
Elle doit contenir une phrase courte de description de la fonction. Ensuite une description plus complète peut être écrite. Si les sorties et les entrées de la fonction ne sont pas évidentes, il faut ajouer un bloc INPUT et un bloc OUTPUT. Comme on le voit ici, il est possible d'écrire des formules en LaTEX dans un bloc MATH, de faire des références à un article wikipedia, un site, une autre fonction. La documentation doit aussi contenir des exemples d'utilisation de la fonction et éventuellement des tests.\smallskip\\
Le manuel de référence de Sage est ensuite automatiquement construit à partir de cette documentation:
\begin{center}
  \includegraphics[scale=0.52]{hughesdocmanual.png}\\
  Extrait de la documentation dans le manuel de référence
\end{center}
\bigskip
  On peut maintenant construire la librairie de Sage en utilisant la commande \texttt{sage -b} dans un terminal. Les modifications qu'on a apporté seront maintenant prises en compte lorsqu'on utilisera Sage. Il est souvent nécessaire d'utiliser la commande \texttt{sage -t block\_design.py} qui permet de tester les exemples mis dans la documentation et éventuellement d'afficher les erreurs dans le cas où il y en a.
\begin{center}
 \includegraphics[scale=0.7]{hugheserror.png}
\end{center}






\newpage
\subsection{La programmation linéaire}
  Un programme linéaire est un système d’équations linéaires dont on cherche une solution optimale. Résoudre un programme linéaire revient à trouver la valeur des variables qui maximise (ou minimise) une fonction objectif, tout en satisfaisant un système de contraintes.\vspace{1\baselineskip}\\
\textbf{Exemple}\\
  On cherche à maximiser $x + y + 3z$ tel que : \\
  $x + 2y \leq 4$\\
  $5z - y \leq 8$\\
  La solution ici est $x = 4, y = 0, z = 1.6$\vspace{1\baselineskip}\\
Nous utilisons la programmation linéaire comme une boite noire. Le fonctionnement de cette boite est compliqué et bien optimisé. Il nous évite la programmation de grandes boucles très couteuses et bien trop longues dès que l'on a suffisamment de variables. Ces boucles testeraient alors toutes les combinaisons pour chercher celle qui maximise la fonction objectif (et encore, cette méthode n'est pas vraiment possible sur les réels ou les entiers).\\
C'est un outil très utile pour les problèmes combinatoires.\vspace{1\baselineskip}\\
\textbf{Exemple}\\
  Pour comprendre les problèmes que l'on va chercher à résoudre, nous allons prendre un exemple plus concret:\vspace{1\baselineskip} \\
  On a devant nous notre sac à dos ayant une capacité limitée C que nous devons remplir avec des objets à notre disposition ayant chacun une utilité et un poids propres fixés entre 0 et 1. Par exemple, une gourde aura un poids de 0.39 pour une utilité de 0.85 tandis qu'un livre aura un poids de 0.35 pour une utilité de 0.26 (selon le livre).\vspace{1\baselineskip}\\
  Soit o un objet. On va introduire une variable binaire ``prendre'' telle que $prendre[o]=1$ si on prend o et 0 si on ne le prend pas. \\
  Notre objectif est d'avoir un sac rempli des objets les plus utiles, on veut donc maximiser:
  \begin{center}
    $\sum_o utilit\acute{e}[o] * prendre[o]$
  \end{center}
  Cependant notre sac ayant une capacité limitée, il faut bien ajouter une contrainte sur le poids:
  \begin{center}
    $\sum_o poids[o] * prendre[o] \leq C$
  \end{center}
  Grâce à la programmation linéaire, on pourra donc savoir quelle combinaison d'objets pouvant rentrer dans notre sac est la plus utile.
\newpage
\subsubsection*{Dans Sage}
Nous avons dans Sage la classe \texttt{MixedIntegerLinearProgram} qui représente les programmes linéaires que nous avons vu.
Nous allons résoudre le premier exemple avec Sage:
\begin{sageverbatim}
 sage: p = MixedIntegerLinearProgram()
 sage: x, y, z = p['x'], p['y'], p['z']    # on definit les variables
 sage: p.set_objective( x + y + 3*z )
 sage: p.add_constraint( x + 2*y <= 4 )
 sage: p.add_constraint ( 5*z - y <= 8 )
 sage: p.solve()         # sage nous retourne la valeur maximale de l'objectif
 8.8
 sage: p.get_values(x,y,z)    # on peut demander les valeurs des variables
 [4.0, 0.0, 1.6]
\end{sageverbatim}
\subsubsection*{Les fonctions arc et blocking\_set}
La programmation linéaire va nous être utile pour trouver les arcs et les blocking set dans les plans projectifs finis. En effet, en associant une valeur binaire à chaque point du plan : 1 si on prend le point dans l'ensemble recherché, 0 sinon.\\
A partir de cet énoncé, on peut faire un programme pour trouver un arc de cardinalité maximale ou un \textit{committee} (un \textit{blocking set} de cardinalité minimale).

Soit s une structure d'incidence :

\begin{lstlisting}
from sage.numerical.mip import MIPSolverException
from sage.categories.sets_cat import EmptySetError
          
def arc(s):   
    p = MixedIntegerLinearProgram()
    b = p.new_variable(binary=True)
    # La variable b est une variable binaire 

    p.set_objective(p.sum(b[v] for v in s._points))
    # Notre objectif est le nombre de points dans notre arc 

    for i in s._blocks:
        p.add_constraint(p.sum(b[k] for k in i) <= 2)
    # On ne doit avoir au maximum que deux points d'un arc sur une ligne 
        
    try:
        p.solve()
        r = p.get_values(b)
        return [i for (i,j) in r.items() if j == 1]
    except MIPSolverException:
        raise EmptySetError('There is  no arc in this incidence structure.')
\end{lstlisting}
La méthode \textbf{try}/\textbf{except} permet de tester un énoncé sans craindre les erreurs qui pourraient arrêter le programme. Ici, si \textit{p.solve()} fonctionne (i.e. on trouve des solutions à ce problème linéaire), alors on renvoie les résultats. Si l'erreur MIPSolverException est générée par le solveur (i.e. il ne trouve pas de solutions), on choisit alors de renvoyer l'erreur EmptySetError qui correspond aux cas où l'ensemble des solutions est vide.
\newpage
\begin{lstlisting}
def blocking_set(s):
    p=MixedIntegerLinearProgram(maximization=False)
    # On minimise plutot que maximise 

    b=p.new_variable(binary=True)
    p.set_objective(p.sum(b[v] for v in s._points))
    for i in s._blocks:
        p.add_constraint(p.sum(b[k] for k in i)>=1)
        # On doit passer par chaque ligne

        p.add_constraint(p.sum(b[k] for k in i)<=len(i)-1)
        # Aucune ligne ne doit etre contenue entiere 
        
    try:
        p.solve()
        r=p.get_values(b)
        return [i for (i,j) in r.items() if j==1]
    except MIPSolverException :
        raise EmptySetError('There is no blocking set in this
    incidence structure')  
\end{lstlisting}
\vspace{1\baselineskip}

\textbf{Remarque}\\
Ces programmes pour trouver les arcs et les blocking set des plans projectifs sont efficaces pour les plans de petite taille mais deviennent trop lents pour des plans d'ordre suffisamment grands. Ceci est du au MIPSolver qui n'est pas assez efficace lorsque le nombre de variables est trop grand (étant donné que ce nombre évolue en $k^2 + k + 1$ par rapport à l'ordre).\\
J'ai suivi la veille de la remise de ce rapport un atelier sur les solveurs SATavec Laurent Simon, chercheur au LaBRI et professeur à l'Enseirb-Matmeca. Ces solveurs travaillent sur des variables booléennes (True / False) et cherchent quelle doit être la valeur de ces variables pour satisfaire une formule de logique propositionnelle (une formule utilisant les variables et les connecteurs 'et', 'ou', 'non', 'implique', 'équivaut'). Les solveurs SAT sont plus efficaces que les solveurs MIP.
\newpage
\section*{Le logiciel Git}
Bien que le logiciel Git passe au second plan, ce logiciel m'a été utile pendant toute la durée de ce stage.\\
Git est un logiciel de gestion de versions décentralisé. C'est donc un logiciel utilisés pour le développement et celui-ci ne se fait pas sur un serveur centralisé, chaque personne développe depuis son propre ``dépot''. Git est particulièrement utile lorsque plusieurs personnes travaillent sur un même projet pour ne pas se perdre dans les modifications des autres ou les écraser, etc... Même seul-e, git permet de garder un historique et les sauvegardes des anciennes versions du code source sur lequel on travaille.\\
Jusqu'ici, il ne s'agit que d'un logiciel de gestion de sauvegardes. Git retient en plus qui a fait telle modification et pourquoi (la personne écrit une courte phrase pour chaque modification faite). On peut aussi fusionner deux versions d'un document en évitant d'écraser le travail de l'autre personne. En effet, git travaille sur plusieurs branches (versions parallèles d'un même projet).\vspace{1\baselineskip}\\

Sage utilise git pour son développement. Sage utilise les branches \textit{master} et \textit{develop}. \textit{master} est la branche de la dernière version stable du logiciel Sage. \textit{develop} est la branche de développement de Sage, elle se fusionne à la branche \textit{master} lors d'une nouvelle version stable. Enfin, pour chaque ticket sur le trac, une branche git est créée, si la modification est validée sur ce ticket, la branche est fusionnée à la branche \textit{develop}. Bien sûr, je n'ai pas les autorisations de faire moi-même ces fusions. On peut néanmoins récupérer les versions de ces branches et accéder à tout l'historique depuis les premières étapes de création du logiciel. \vspace{2\baselineskip}\\
\begin{center}
  \includegraphics[scale=0.5]{trac.png}\\
  Interface trac pour le développement de Sage
\end{center}
\vspace{1\baselineskip}
En plus de l'utiliser pour participer au développement de Sage, git m'a permis de communiquer plus facilement tous les fichiers nécessaires à mon maitre de stage via GitHub qui est une sorte de réseau social pour développeurs sur lequel chaque personne peut poster son projet. Ainsi, j'ai pu envoyer et mettre à jour sur ce site tous les fichiers que je créais ou modifiais. A partir de ces fichiers, on peut me proposer des modifications sur une nouvelle branche que je peux choisir de fusionner avec la mienne ou encore récupérer les fichiers que j'ai mis en ligne.


\newpage
\section*{Bilan}
\addcontentsline{toc}{section}{Bilan}
En regardant l'intitulé de mon sujet de stage, je pense avoir aujourd'hui avoir tout assimilé et avoir atteint mes objectifs. Mon stage n'étant pas fini, il me reste encore quelques semaines pour m'occuper du ticket sur les arcs et les blocking sets, m'intéresser aux plans de Hall et peut-être implémenter une fonction dans Sage pour construire ces plans aussi. J'ai compris comment le développement de Sage se faisait et acquis beaucoup de connaissances en Python.\\

\newpage
\thispagestyle{empty}
\addcontentsline{toc}{section}{Annexes}
\section*{Annexe 1}
Code de la fonction \texttt{HughesPlane}
\begin{lstlisting}
def HughesPlane(q2, check=True):
    if not q2.is_square():
        raise EmptySetError("No Hughes plane of non-square order exists.")
    if q2%2 == 0:
        raise EmptySetError("No Hughes plane of even order exists.")
    q = q2.sqrt()
    K = FiniteField(q2, prefix='x', conway=True)
    F = FiniteField(q, prefix='y', conway=True)
    A = q3_minus_one_matrix(F)
    A = A.change_ring(K)
    m = K.list()
    V = VectorSpace(K, 3)
    zero = K.zero()
    one = K.one()
    points = [(x, y, one) for x in m for y in m] + \
             [(x, one, zero) for x in m] + \
             [(one, zero, zero)]
    relabel = {tuple(p):i for i,p in enumerate(points)}
    blcks = []
    for a in m:
        if a not in F or a == 1:
            # build L(a)
            aa = ~ a
            l = []
            l.append(V((-a, one, zero)))
            for x in m:
                y = - aa * (x + one)
                if not y.is_square():
                    y *= aa**(q - 1)
                l.append(V((x, y, one)))
            # compute the orbit of L(a)
            blcks.append([relabel[normalize_hughes_plane_point(p,q)] for p in l])
            for i in range(q2 + q):
                l = [A*j for j in l]
                blcks.append([relabel[normalize_hughes_plane_point(p,q)] for p in l])
    from bibd import BalancedIncompleteBlockDesign
    return BalancedIncompleteBlockDesign(q2**2+q2+1, blcks, check=check)
\end{lstlisting}
\bigskip
Ligne 9 : \texttt{q3\_minus\_one\_matrix()} est une fonction que j'ai faite pour nous donner une matrice vérifiant les propriétés énoncées pour le plan de Hughes. \smallskip\\
Ligne 10 : \texttt{.change\_ring()} est une méthode qui sert à ce que les éléments de $GF(q)$ soient considérés comme des éléments de $GF(q^2)$.\smallskip\\
Ligne 18 : on a besoin de \texttt{relabel} pour associer aux coordonées des points un numéro de point qui sera plus simple à traiter ensuite.\smallskip\\
Ligne 23 : ~a est l'inverse de a.\smallskip\\
Ligne 32 : \texttt{normalize\_hughes\_plane\_point()} est une fonction que j'ai faite pour normaliser les points ayant des coordonnées équivalentes.\smallskip\\
Ligne 37 : \texttt{check} est une variable booléenne qui fera vérifier que la structure qu'on lui donne est bien un \texttt{BalancedIncompleteBlockDesign} si sa valeur. Elle se met à True si non-renseignée mais peut-être mise à False pour accélérer les programmes.
\newpage
\thispagestyle{empty}
\section*{Annexe 2}
Documentation de la fonction \texttt{HughesPlane}
\begin{lstlisting}
def HughesPlane(q2, check=True):
    r"""
    Return the Hughes projective plane of order ``q2``.

    Let `q` be an odd prime, the Hughes plane of order `q^2` is a finite
    projective plane of order `q^2` introduced by D. Hughes in [Hu57]_. Its
    construction is as follows.

    Let `K = GF(q^2)` be a finite field with `q^2` elements and `F = GF(q)
    \subset K` be its unique subfield with `q` elements. We define a twisted
    multiplication on `K` as

    .. MATH::

        x \circ y =
        \begin{cases}
        x\ y & \text{if y is a square in K}\\
        x^q\ y & \text{otherwise}
        \end{cases}

    The points of the Hughes plane are the triples `(x, y, z)` of points in `K^3
    \backslash \{0,0,0\}` up to the equivalence relation `(x,y,z) \sim (x \circ
    k, y \circ k, z \circ k)` where `k \in K`.

    For `a = 1` or `a \in (K \backslash F)` we define a block `L(a)` as the set
    of triples `(x,y,z)` so that `x + a \circ y + z = 0`. The rest of the blocks
    are obtained by letting act the group `GL(3, F)` by its standard action.

    For more information, see :wikipedia:`Hughes_plane` and [We07].

    .. SEEALSO::

        :func:`DesarguesianProjectivePlaneDesign` to build the Desarguesian
        projective planes

    INPUT:

    - ``q2`` -- an even power of an odd prime number

    - ``check`` -- (boolean) Whether to check that output is correct before
      returning it. As this is expected to be useless (but we are cautious
      guys), you may want to disable it whenever you want speed. Set to
      ``True`` by default.

    EXAMPLES::

        sage: H = designs.HughesPlane(9)
        sage: H
        (91,10,1)-Balanced Incomplete Block Design

    We prove in the following computations that the Desarguesian plane ``H`` is
    not Desarguesian. Let us consider the two triangles `(0,1,10)` and `(57, 70,
    59)`. We show that the intersection points `D_{0,1} \cap D_{57,70}`,
    `D_{1,10} \cap D_{70,59}` and `D_{10,0} \cap D_{59,57}` are on the same line
    while `D_{0,70}`, `D_{1,59}` and `D_{10,57}` are not concurrent::

        sage: blocks = H.blocks()
        sage: line = lambda p,q: (b for b in blocks if p in b and q in b).next()

        sage: b_0_1 = line(0, 1)
        sage: b_1_10 = line(1, 10)
        sage: b_10_0 = line(10, 0)
        sage: b_57_70 = line(57, 70)
        sage: b_70_59 = line(70, 59)
        sage: b_59_57 = line(59, 57)

        sage: set(b_0_1).intersection(b_57_70)
        {2}
        sage: set(b_1_10).intersection(b_70_59)
        {73}
        sage: set(b_10_0).intersection(b_59_57)
        {60}

        sage: line(2, 73) == line(73, 60)
        True

        sage: b_0_57 = line(0, 57)
        sage: b_1_70 = line(1, 70)
        sage: b_10_59 = line(10, 59)

        sage: p = set(b_0_57).intersection(b_1_70)
        sage: q = set(b_1_70).intersection(b_10_59)
        sage: p == q
        False

    TESTS:

    Some wrong input::

        sage: designs.HughesPlane(5)
        Traceback (most recent call last):
        ...
        EmptySetError: No Hughes plane of non-square order exists.

        sage: designs.HughesPlane(16)
        Traceback (most recent call last):
        ...
        EmptySetError: No Hughes plane of even order exists.

    Check that it works for non-prime `q`::

        sage: designs.HughesPlane(3**4)    # not tested - 10 secs
        (6643,82,1)-Balanced Incomplete Block Design
    """
\end{lstlisting}       
\thispagestyle{empty}
\newpage
\thispagestyle{empty}

\section*{Annexe 3}
Dobble à 7 cartes\bigskip\\
\includegraphics[scale=0.43]{dobble1.png}
\includegraphics[scale=0.43]{dobble2.png}\\
\includegraphics[scale=0.43]{dobble3.png}
\includegraphics[scale=0.43]{dobble4.png}\\
\includegraphics[scale=0.43]{dobble5.png}
\includegraphics[scale=0.43]{dobble6.png}\\
\includegraphics[scale=0.43]{dobble7.png}
\end{document}
